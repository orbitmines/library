# OrbitMines Library
A library for Intercommunication between Languages. The *indexing, analysis ..., comparison* of existing abstract models of *computation, mathematics, calculi, theorem-provers, compilers, proof assistants, automated program synthesizers, ..., (programming) languages*.

:github: [github.com/orbitmines/library](https://github.com/orbitmines/library) (:orbitmines: :discord: [OrbitMines](https://discord.com/channels/1055502602365845534/1200246205473619968), :semf: :discord: [SEMF](https://discord.com/channels/844566471501414463/1225907185079287971))

---
###### Timeline
- [ ] Prerequisite: [[Writing - 2024. A Universal Language]]
- **Collaboration Setup**
	- [ ] Collaboration tooling: Create a way of analyzing/comparing them which **does not** include manual human labor of specifying their grammars.
	- [ ] Compile scripts for this repository, so a writing/study of this can be automatically compiled to some PDF, ..., LaTeX setting.
- **[[People Index]]**
	- [ ] Compile a list of people who need to be contacted for this
	- [ ] **[[Finding Collaborators]]**: Are there people who have compiled something like this yet? There are probably many people who are thinking about something like this in the context of *biology, meta-research, ..., other fields* too. Find out who?
	- [ ] **[[Legal]]**: Just exclude the ones without open licenses *or contact all of them to lift the licenses*.
- **[[Project Index]]**
	- [ ] The only stuff I've been able to find so far is either incredibly limited in scope or is doing too much of this by hand. Would love to find out that there's someone who has been working on this already though.
	- [ ] **Differentiation:** Measurement of category if diversity for the thing its useful for ; this is essentially the closeness idea ([More usefully: How much do I need to change/ignore before they're the same to me?](https://orbitmines.com/papers/on-orbits-equivalence-and-inconsistencies#:~:text=More%20usefully%3A%20How%20much%20do%20I%20need%20to%20change/ignore%20before%20they%27re%20the%20same%20to%20me%3F)) 
		- Basically, how much shifting/.../ignoring do I have to do before particular kind of symmetries/equivalences are reached so there's an/.../better interface into it.
		- Becomes "contextual/.../computational closeness?"
		- Language barriers / Different perspectives
			- Get things like taking items from one particular world back to another world, could suddenly see quests you couldn't see before (immigration / ...).
			- Switching between different abstraction levels
		- [ ] What are mistakes in trying to spin up new projects/languages? 
		- [ ] Compiled grammar vs analysis of runtimes?
			- [ ] What can be (partially) compiled to what using what? (Natively supported vs finding (accidental) symmetries to allow for compilation)
			- [ ] Apply this question again by loosely changing constraints?
		- [ ] What mistake in indexing multiple levels of descriptions ; Non-overlap, points resulting in confusion etc..
		- [ ] Realized invariances/.../redundancies of particular layers.
		- [ ] Part of this becomes how do certain fields/perspectives/projects have a view on other projects (partly [[PENDING (2032+?); Sociology, Economics]]). A simple example is confusion between programming fields in what the meaning of frontend/backend is. - People's fixation on using a particular word very specifically. That sort of thing.
			- complex/complicated is another example
			- another is hardware/software distinction (in the sense of superposed languages, this fails a bit). This distinction isn't really that clear-cut.
